<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Zoho Sales IQ Report Generator - Ultra Wide Dark Mode</title>
  <style>
    :root {
      --background: #121217;
      --card-bg: #1e1e28;
      --text-primary: #e1e1e6;
      --text-secondary: #8b8baf;
      --accent-primary: #9068f3;
      --accent-secondary: #cfc5ff;
      --border-color: #292934;
      --table-header-bg: #2c2c3c;
      --table-row-hover: #2f2f41;
      --button-bg: linear-gradient(90deg,#9068f3 0%,#6c47ff 100%);
      --button-bg-hover: linear-gradient(90deg,#6c47ff 0%,#9068f3 100%);
    }
    html, body {
      margin: 0;
      padding: 0;
      background-color: var(--background);
      color: var(--text-primary);
      font-family: "Inter", system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: flex-start;
      padding: 48px 12px;
      font-size: 16px;
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
    }
    .card {
      background-color: var(--card-bg);
      border-radius: 12px;
      max-width: 99vw;
      width: 100vw;
      padding: 32px 60px 40px;
      box-shadow: 0 4px 14px 0 rgb(100 81 255 / 0.2);
      display: flex;
      flex-direction: column;
      align-items: stretch;
      gap: 28px;
      box-sizing: border-box;
      overflow-x: hidden;
    }
    h1 {
      margin: 0 auto;
      font-weight: 700;
      font-size: 2.5rem;
      max-width: 980px;
      color: var(--accent-primary);
      background: linear-gradient(90deg,var(--accent-primary) 0%,var(--accent-secondary) 100%);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      text-fill-color: transparent;
      user-select: none;
      text-align: center;
    }
    label {
      color: var(--text-secondary);
      font-weight: 600;
      font-size: 0.95rem;
      margin-bottom: 8px;
      user-select: none;
      max-width: 980px;
      margin-left: auto;
      margin-right: auto;
      display: block;
    }
    input[type="file"] {
      max-width: 980px;
      margin: 0 auto 12px;
      display: block;
      padding: 14px 20px;
      border-radius: 10px;
      outline: none;
      border: 1px solid var(--border-color);
      background-color: #2b2b39;
      color: var(--text-primary);
      font-size: 1.1rem;
      cursor: pointer;
      transition: border-color 0.3s;
      width: 100%;
      box-sizing: border-box;
    }
    input[type="file"]:focus {
      border-color: var(--accent-primary);
    }
    .button-group {
      max-width: 980px;
      margin: 0 auto;
      display: flex;
      gap: 16px;
      width: 100%;
      box-sizing: border-box;
    }
    button {
      flex: 1;
      padding: 16px 0;
      border-radius: 12px;
      border: none;
      background: var(--button-bg);
      color: white;
      font-weight: 750;
      font-size: 1.2rem;
      letter-spacing: 0.05em;
      cursor: pointer;
      transition: background 0.3s ease;
      user-select: none;
      box-sizing: border-box;
      font-family: "Inter", system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
    }
    button:hover {
      background: var(--button-bg-hover);
    }
    button:disabled {
      background: #555467;
      cursor: default;
      color: #b0afc6;
    }
    .report-wrapper {
      margin: 0 auto;
      max-width: 780px;
      width: 100%;
    }
    .report-section {
      display: flex;
      flex-wrap: nowrap;
      align-items: flex-start;
      gap: 32px;
      border-bottom: 1px solid var(--border-color);
      padding-bottom: 32px;
      box-sizing: border-box;
    }
    .report-title {
      font-size: 1.5rem;
      font-weight: 700;
      margin-bottom: 16px;
      border-bottom: 2px solid var(--accent-primary);
      padding-bottom: 8px;
      flex-basis: 100%;
      color: var(--text-primary);
    }
    table {
      flex: 1 1 75%;
      border-collapse: separate;
      border-spacing: 0;
      width: 100%;
      border-radius: 10px;
      overflow: hidden;
      background-color: #242436;
      box-shadow: 0 0 0 1px var(--border-color);
      font-size: 1rem;
      color: var(--text-primary);
      transition: width 0.3s ease;
    }
    th, td {
      padding: 16px 24px;
      text-align: left;
      border-bottom: 1px solid var(--border-color);
      white-space: nowrap; /* Ensures one row per entry, no text-wrap */
    }
    th {
      background-color: var(--table-header-bg);
      font-weight: 700;
      color: var(--text-secondary);
      user-select: none;
    }
    tbody tr:hover {
      background-color: var(--table-row-hover);
    }
    .chart-container {
      width: 440px;
      height: 440px;
      flex-shrink: 0;
      background-color: #1e1e28;
      border-radius: 12px;
      padding: 36px;
      box-sizing: border-box;
      box-shadow: 0 0 24px #6c47ffbb;
      transition: width 0.3s ease, height 0.3s ease;
    }
    #pdfButton {
      max-width: 780px;
      margin: 0 auto 24px;
      background: linear-gradient(90deg,#ef4444 0%,#dc2626 100%);
      font-size: 1.1rem;
      width: 100%;
      display: none;
    }
    #pdfButton:hover {
      background: linear-gradient(90deg,#dc2626 0%,#b91c1c 100%);
    }
    #pdfButton.show {
      display: block;
    }
    @media (max-width: 1400px) {
      .card {
        max-width: 96vw;
        padding: 28px 44px;
      }
      .report-section {
        gap: 28px;
        padding-bottom: 28px;
      }
      table {
        flex: 1 1 70%;
      }
      .chart-container {
        width: 380px;
        height: 380px;
        padding: 32px;
      }
    }
    @media (max-width: 900px) {
      .card {
        padding: 24px 20px;
      }
      .report-section {
        flex-wrap: wrap;
      }
      table, .chart-container {
        width: 100% !important;
        flex: none !important;
        transition: none;
      }
      .chart-container {
        height: 280px !important;
        padding: 20px !important;
      }
      .button-group {
        flex-direction: column;
      }
    }
  </style>
</head>
<body>
  <div class="card">
    <h1>Zoho Sales IQ Report Generator</h1>
    <label for="fileInput">Upload Excel or CSV file</label>
    <input type="file" id="fileInput" accept=".xls,.xlsx,.csv" />
    <div class="button-group">
      <button id="generateBtn" disabled>Generate Report</button>
    </div>
    <button id="pdfButton">üì• Convert to PDF</button>
    <div class="report-wrapper">
      <div class="report" id="reportContainer"></div>
    </div>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/html2pdf.js/0.10.1/html2pdf.bundle.min.js"></script>
  <script>
    const fileInput = document.getElementById('fileInput');
    const generateBtn = document.getElementById('generateBtn');
    const reportContainer = document.getElementById('reportContainer');
    const pdfButton = document.getElementById('pdfButton');

    fileInput.addEventListener('change', () => {
      generateBtn.disabled = !fileInput.files.length;
      reportContainer.innerHTML = '';
      pdfButton.classList.remove('show');
    });

    generateBtn.addEventListener('click', async () => {
      if (!fileInput.files.length) return;
      const data = await readFile(fileInput.files[0]);
      const { headers, rows } = getProcessedData(data);
      const reportHtml = generateReport(headers, rows);
      reportContainer.innerHTML = reportHtml;
      buildCharts(headers, rows);
      pdfButton.classList.add('show');
    });

    pdfButton.addEventListener('click', () => {
      const element = document.querySelector('.report-wrapper');
      const opt = {
        margin: 15,
        filename: 'Zoho_Sales_IQ_Report.pdf',
        image: { type: 'jpeg', quality: 0.98 },
        html2canvas: { scale: 2 },
        jsPDF: { orientation: 'portrait', unit: 'mm', format: 'a4' }
      };
      html2pdf().set(opt).from(element).save();
    });

    function readFile(file) {
      return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = (e) => {
          try {
            const uint8Array = new Uint8Array(e.target.result);
            const workbook = XLSX.read(uint8Array, { type: 'array' });
            const worksheet = workbook.Sheets[workbook.SheetNames[0]];
            const data = XLSX.utils.sheet_to_json(worksheet, { header: 1 });
            resolve(data);
          } catch (err) {
            reject(err);
          }
        };
        reader.readAsArrayBuffer(file);
      });
    }

    function findHeaderRow(data) {
      for (let i = 0; i < data.length; i++) {
        const row = data[i] || [];
        const filled = row.filter(cell => cell && cell.toString().trim() !== '').length;
        if (
          filled === 0 ||
          (filled === 1 && (row[0] || '').toString().trim().toLowerCase() === 'history')
        ) continue;
        return i;
      }
      return 0;
    }

    function getProcessedData(data) {
      const headerRowIndex = findHeaderRow(data);
      const headers = (data[headerRowIndex] || []).map(h => (h ? h.toString().toLowerCase() : ''));
      const rows = data.slice(headerRowIndex + 1);
      return { headers, rows };
    }

    function parseCustomerInfo(cell) {
      try {
        if (!cell || typeof cell !== 'string') return 'Other';
        const obj = JSON.parse(cell);
        if (typeof obj === 'object') {
          return obj['visit.q1'] || 'Other';
        }
        return 'Other';
      } catch (e) {
        return 'Other';
      }
    }

    function hmsToSeconds(str) {
      if (!str) return 0;
      const parts = str.split(':').map(Number);
      while (parts.length < 3) parts.unshift(0);
      const [hours, minutes, seconds] = parts;
      return hours * 3600 + minutes * 60 + seconds;
    }

    function formatDuration(sec) {
      sec = Math.round(sec);
      if (isNaN(sec)) return 'N/A';
      const h = Math.floor(sec / 3600);
      const m = Math.floor((sec % 3600) / 60);
      const s = sec % 60;
      return (h > 0 ? `${h}h ` : '') + (m > 0 ? `${m}m ` : '') + `${s}s`;
    }

    function sortByCount(obj) {
      return Object.entries(obj).sort((a, b) => b[1] - a[1]);
    }

    function filteredByMinPct(array, total) {
      return array.filter(([_, count]) => (count / (total || 1)) * 100 >= 0.5);
    }

    function generateReport(headers, rows) {
      if (!headers.length || !rows.length) return '<p>No data to analyze.</p>';

      const getColIdx = keyword => headers.findIndex(h => h.includes(keyword));
      const customerCol = getColIdx('customer info');
      const embedCol = getColIdx('embed');
      const countryCol = getColIdx('country');
      const durationHMSCol = getColIdx('chat duration(in secs)');
      const avgResponseTimeHMSCol = getColIdx('average response time(in secs)');
      const firstAgentRespTimeHMSCol = getColIdx('first agent first response time(in secs)');
      const visitorMsgCountCol = getColIdx('visitor message count');
      const operatorMsgCountCol = getColIdx('operator message count');

      const subjectsList = ['bonus/free spins', 'withdrawal', 'account', 'deposit', 'game issue', 'verification'];
      const customerBreakdown = {};
      subjectsList.forEach(s => (customerBreakdown[s] = 0));
      let customerOther = 0,
        totalChats = 0;
      rows.forEach(row => {
        const cell = customerCol !== -1 ? row[customerCol] : '';
        const parsed = parseCustomerInfo(cell).toLowerCase();
        const normalized = subjectsList.find(s => s === parsed);
        if (normalized) customerBreakdown[normalized]++;
        else customerOther++;
        totalChats++;
      });
      customerBreakdown['other'] = customerOther;
      const sortedSubjects = sortByCount(customerBreakdown);

      const brandsCount = {};
      rows.forEach(row => {
        const val = embedCol !== -1 && row[embedCol] ? row[embedCol].trim().toLowerCase() : 'unknown';
        brandsCount[val] = (brandsCount[val] || 0) + 1;
      });
      const sortedBrands = sortByCount(brandsCount);
      const totalBrands = Object.values(brandsCount).reduce((a, b) => a + b, 0);

      const countriesCount = {};
      rows.forEach(row => {
        const val = countryCol !== -1 && row[countryCol] ? row[countryCol].trim().toLowerCase() : 'unknown';
        countriesCount[val] = (countriesCount[val] || 0) + 1;
      });
      const sortedCountries = sortByCount(countriesCount);
      const totalCountries = Object.values(countriesCount).reduce((a, b) => a + b, 0);

      function avgTimeCol(colIdx) {
        if (colIdx === -1) return 'N/A';
        let sum = 0,
          count = 0;
        rows.forEach(r => {
          const sec = hmsToSeconds(r[colIdx]);
          if (!isNaN(sec) && sec > 0) {
            sum += sec;
            count++;
          }
        });
        return count ? formatDuration(sum / count) : 'N/A';
      }

      function avgCountCol(colIdx) {
        if (colIdx === -1) return 'N/A';
        let sum = 0,
          cnt = 0;
        rows.forEach(r => {
          const v = parseFloat(r[colIdx]);
          if (!isNaN(v)) {
            sum += v;
            cnt++;
          }
        });
        return cnt ? (sum / cnt).toFixed(2) : 'N/A';
      }

      const avgChatDuration = avgTimeCol(durationHMSCol);
      const avgResponseTime = avgTimeCol(avgResponseTimeHMSCol);
      const avgFirstAgentRespTime = avgTimeCol(firstAgentRespTimeHMSCol);
      const avgVisitorMsgCount = avgCountCol(visitorMsgCountCol);
      const avgOperatorMsgCount = avgCountCol(operatorMsgCountCol);

      let html = `
    <div class="report-section">
      <div style="flex: 1 1 75%;">
        <h2 class="report-title">üó®Ô∏è Chat Subject</h2>
        <table>
          <thead><tr><th>Subject</th><th>Chats</th><th>Percentage</th></tr></thead><tbody>\n`;

      sortedSubjects.forEach(([key, val]) => {
        html += `<tr><td>${capitalize(key)}</td><td>${val}</td><td>${((val / totalChats) * 100).toFixed(
          1,
        )}%</td></tr>\n`;
      });

      html += `</tbody></table></div>
      <div class="chart-container"><canvas id="chatSubjectChart"></canvas></div></div>`;

      html += `
    <div class="report-section">
      <div style="flex: 1 1 75%;">
        <h2 class="report-title">üè¢ Brands Breakdown</h2>
        <table>
          <thead><tr><th>Brand</th><th>Chats</th><th>Percentage</th></tr></thead><tbody>\n`;

      sortedBrands.forEach(([key, val]) => {
        html += `<tr><td>${capitalize(key)}</td><td>${val}</td><td>${(
          (val / totalBrands) *
          100
        ).toFixed(1)}%</td></tr>\n`;
      });

      html += `</tbody></table></div>
      <div class="chart-container"><canvas id="brandsChart"></canvas></div></div>`;

      html += `
    <div class="report-section">
      <div style="flex: 1 1 75%;">
        <h2 class="report-title">üåç Countries Breakdown</h2>
        <table>
          <thead><tr><th>Country</th><th>Chats</th><th>Percentage</th></tr></thead><tbody>\n`;

      filteredByMinPct(sortedCountries, totalCountries).forEach(([key, val]) => {
        html += `<tr><td>${capitalize(key)}</td><td>${val}</td><td>${(
          (val / totalCountries) *
          100
        ).toFixed(1)}%</td></tr>\n`;
      });

      html += `</tbody></table></div>
      <div class="chart-container"><canvas id="countriesChart"></canvas></div></div>`;

      html += `
      <div class="report-section" style="flex-direction: column; border: none; padding-bottom: 0;">
        <h2 class="report-title">‚è±Ô∏è Performance Metrics</h2>
        <table>
          <tbody>
            <tr><th>Metric</th><th>Average</th></tr>
            <tr><td>Chat Duration</td><td>${avgChatDuration}</td></tr>
            <tr><td>Response Time</td><td>${avgResponseTime}</td></tr>
            <tr><td>First Agent Response Time</td><td>${avgFirstAgentRespTime}</td></tr>
            <tr><td>Visitor Messages</td><td>${avgVisitorMsgCount}</td></tr>
            <tr><td>Operator Messages</td><td>${avgOperatorMsgCount}</td></tr>
          </tbody>
        </table>
      </div>
      `;

      return html;
    }

    function buildCharts(headers, rows) {
      setTimeout(() => {
        const ctxSubject = document.getElementById('chatSubjectChart')?.getContext('2d');
        const ctxBrands = document.getElementById('brandsChart')?.getContext('2d');
        const ctxCountries = document.getElementById('countriesChart')?.getContext('2d');

        if (!ctxSubject || !ctxBrands || !ctxCountries) return;

        const getColIdx = keyword => headers.findIndex(h => h.includes(keyword));
        const customerCol = getColIdx('customer info');
        const embedCol = getColIdx('embed');
        const countryCol = getColIdx('country');

        const subjectsList = ['bonus/free spins', 'withdrawal', 'account', 'deposit', 'game issue', 'verification'];
        const customerBreakdown = {};
        subjectsList.forEach(s => (customerBreakdown[s] = 0));
        let customerOther = 0,
          totalChats = 0;
        rows.forEach(row => {
          const cell = customerCol !== -1 ? row[customerCol] : '';
          const parsed = parseCustomerInfo(cell).toLowerCase();
          const normalized = subjectsList.find(s => s === parsed);
          if (normalized) customerBreakdown[normalized]++;
          else customerOther++;
          totalChats++;
        });
        customerBreakdown['other'] = customerOther;
        const sortedSubjects = sortByCount(customerBreakdown);

        const brandsCount = {};
        rows.forEach(row => {
          const val = embedCol !== -1 && row[embedCol] ? row[embedCol].trim().toLowerCase() : 'unknown';
          brandsCount[val] = (brandsCount[val] || 0) + 1;
        });
        const sortedBrands = sortByCount(brandsCount);
        const totalBrands = Object.values(brandsCount).reduce((a, b) => a + b, 0);

        const countriesCount = {};
        rows.forEach(row => {
          const val = countryCol !== -1 && row[countryCol] ? row[countryCol].trim().toLowerCase() : 'unknown';
          countriesCount[val] = (countriesCount[val] || 0) + 1;
        });
        const sortedCountries = sortByCount(countriesCount);
        const totalCountries = Object.values(countriesCount).reduce((a, b) => a + b, 0);

        const allSubjects = sortedSubjects;
        const allBrands = sortedBrands;
        const filteredCountries = filteredByMinPct(sortedCountries, totalCountries);

        new Chart(ctxSubject, {
          type: 'pie',
          data: {
            labels: allSubjects.map(([k]) => capitalize(k)),
            datasets: [{
              data: allSubjects.map(([_, v]) => v),
              backgroundColor: generateColors(allSubjects.length),
              borderWidth: 0,
            }]
          },
          options: {
            responsive: true,
            maintainAspectRatio: true,
            plugins: {
              legend: {position: 'right', labels: {color: 'white', font: {size: 12}}},
              tooltip: {enabled: true}
            }
          }
        });

        new Chart(ctxBrands, {
          type: 'pie',
          data: {
            labels: allBrands.map(([k]) => capitalize(k)),
            datasets: [{
              data: allBrands.map(([_, v]) => v),
              backgroundColor: generateColors(allBrands.length),
              borderWidth: 0,
            }]
          },
          options: {
            responsive: true,
            maintainAspectRatio: true,
            plugins: {
              legend: {position: 'right', labels: {color: 'white', font: {size: 12}}},
              tooltip: {enabled: true}
            }
          }
        });

        new Chart(ctxCountries, {
          type: 'pie',
          data: {
            labels: filteredCountries.map(([k]) => capitalize(k)),
            datasets: [{
              data: filteredCountries.map(([_, v]) => v),
              backgroundColor: generateColors(filteredCountries.length),
              borderWidth: 0,
            }]
          },
          options: {
            responsive: true,
            maintainAspectRatio: true,
            plugins: {
              legend: {position: 'right', labels: {color: 'white', font: {size: 12}}},
              tooltip: {enabled: true}
            }
          }
        });
      }, 100);
    }

    function generateColors(count) {
      const colors = [
        '#6366f1', '#ef4444', '#facc15', '#22c55e', '#3b82f6',
        '#a855f7', '#f97316', '#14b8a6', '#db2777', '#64748b',
        '#10b981', '#f59e0b', '#2563eb', '#ec4899', '#84cc16',
        '#06b6d4', '#f43f5e', '#8b5cf6', '#eab308', '#22d3ee'
      ];
      let arr = [];
      for (let i = 0; i < count; i++) {
        arr.push(colors[i % colors.length]);
      }
      return arr;
    }

    function sortByCount(obj) {
      return Object.entries(obj).sort((a, b) => b[1] - a[1]);
    }

    function filteredByMinPct(array, total) {
      return array.filter(([_, count]) => (count / (total || 1)) * 100 >= 0.5);
    }

    function capitalize(str) {
      if (!str) return '';
      return str.charAt(0).toUpperCase() + str.slice(1);
    }
  </script>
</body>
</html>
